"use strict";
/**
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.startTestServer = startTestServer;
exports.stopTestServer = stopTestServer;
const child_process_1 = require("child_process");
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const yaml_1 = require("yaml");
const PROJECT_NAME = 'test-server';
const getBinaryPath = () => {
    const platform = process.platform;
    const binaryName = platform === 'win32' ? `${PROJECT_NAME}.exe` : PROJECT_NAME;
    // Assuming this script (when compiled) is in sdks/typescript/dist/index.js
    // So __dirname is sdks/typescript/dist
    const binaryPath = path.resolve(__dirname, '..', 'bin', binaryName);
    if (!fs.existsSync(binaryPath)) {
        throw new Error(`test-server binary not found at ${binaryPath}. ` +
            `This usually means the postinstall script failed to download or extract the binary. ` +
            `Please try reinstalling the test-server-sdk package. ` +
            `If the issue persists, check the output of the postinstall script for errors.`);
    }
    return binaryPath;
};
/**
 * Starts the test-server process.
 * @param options Configuration options for starting the server.
 * @returns The spawned ChildProcess instance.
 */
async function startTestServer(options) {
    const { configPath, recordingDir, mode: optionsMode, env, onStdOut, onStdErr, onExit, onError } = options;
    const binaryPath = getBinaryPath();
    let effectiveMode;
    if (optionsMode === 'record') {
        effectiveMode = 'record';
    }
    else if (optionsMode === 'replay') {
        effectiveMode = 'replay';
    }
    else { // optionsMode === 'cli-driven'
        console.log('Process args: ');
        console.log(process.argv);
        effectiveMode = process.argv.includes('--record') ? 'record' : 'replay';
    }
    const args = [
        effectiveMode,
        '--config',
        configPath,
        '--recording-dir',
        recordingDir,
    ];
    console.log(`[test-server-sdk] Starting test-server in '${effectiveMode}' mode. Command: ${binaryPath} ${args.join(' ')}`);
    const serverProcess = (0, child_process_1.spawn)(binaryPath, args, {
        env: { ...process.env, ...env },
        windowsHide: true, // Hide console window on Windows
    });
    serverProcess.stdout?.on('data', (data) => {
        const output = data.toString();
        if (onStdOut) {
            onStdOut(output);
        }
        else {
            // Default behavior: log to console, clearly marking it.
            output.trimEnd().split('\n').forEach(line => console.log(`[test-server STDOUT] ${line}`));
        }
    });
    serverProcess.stderr?.on('data', (data) => {
        const output = data.toString();
        if (onStdErr) {
            onStdErr(output);
        }
        else {
            // Default behavior: log to console, clearly marking it.
            output.trimEnd().split('\n').forEach(line => console.error(`[test-server STDERR] ${line}`));
        }
    });
    serverProcess.on('exit', (code, signal) => {
        console.log(`[test-server-sdk] test-server process (PID: ${serverProcess.pid}) exited with code ${code} and signal ${signal}`);
        if (onExit) {
            onExit(code, signal);
        }
    });
    serverProcess.on('error', (err) => {
        console.error('[test-server-sdk] Failed to start or manage test-server process:', err);
        if (onError) {
            onError(err);
        }
        else {
            // If no custom error handler, rethrow to make it obvious something went wrong.
            throw err;
        }
    });
    console.log(`[test-server-sdk] test-server process (PID: ${serverProcess.pid}) started.`);
    await awaitHealthyTestServer(options);
    return serverProcess;
}
/**
 * Stops the test-server process.
 * @param serverProcess The ChildProcess instance to stop.
 * @returns A Promise that resolves when the process has exited.
 */
function stopTestServer(serverProcess) {
    return new Promise((resolve, reject) => {
        if (!serverProcess || serverProcess.killed || serverProcess.exitCode !== null) {
            console.log('[test-server-sdk] test-server process already stopped or not running.');
            resolve();
            return;
        }
        const pid = serverProcess.pid;
        console.log(`[test-server-sdk] Attempting to stop test-server process (PID: ${pid})...`);
        // Add listeners specifically for this stop operation
        const exitListener = (code, signal) => {
            clearTimeout(killTimeout);
            console.log(`[test-server-sdk] test-server process (PID: ${pid}) confirmed exit (code: ${code}, signal: ${signal}).`);
            resolve();
        };
        const errorListener = (err) => {
            clearTimeout(killTimeout);
            console.error(`[test-server-sdk] Error during test-server process (PID: ${pid}) termination:`, err);
            reject(err);
        };
        serverProcess.once('exit', exitListener);
        serverProcess.once('error', errorListener);
        const killedBySigterm = serverProcess.kill('SIGTERM');
        if (!killedBySigterm) {
            // This can happen if the process already exited between the check and kill attempt.
            console.warn(`[test-server-sdk] SIGTERM signal to PID ${pid} failed. Process might have already exited.`);
            // Clean up listeners and resolve as the 'exit' event might not fire if already gone.
            serverProcess.removeListener('exit', exitListener);
            serverProcess.removeListener('error', errorListener);
            resolve();
            return;
        }
        console.log(`[test-server-sdk] SIGTERM sent to test-server process (PID: ${pid}). Waiting for graceful exit...`);
        const killTimeout = setTimeout(() => {
            if (!serverProcess.killed && serverProcess.exitCode === null) {
                console.warn(`[test-server-sdk] test-server process (PID: ${pid}) did not terminate with SIGTERM after 5s. Sending SIGKILL.`);
                serverProcess.kill('SIGKILL');
            }
        }, 5000); // 5 seconds timeout
    });
}
/**
 * Waits for the test-server to become healthy by checking the configured health endpoints.
 * It reads the config file and performs health checks on all endpoints that have a 'health' path defined.
 * It uses a retry mechanism with exponential backoff for health checks.
 *
 * @param options Configuration options containing the configPath.
 */
async function awaitHealthyTestServer(options) {
    const configRaw = fs.readFileSync(options.configPath, { encoding: 'utf8' });
    const config = (0, yaml_1.parse)(configRaw);
    for (const endpoint of config['endpoints']) {
        if (!("health" in endpoint)) {
            continue;
        }
        const url = `${endpoint['source_type']}://localhost:${endpoint['source_port']}${endpoint['health']}`;
        await healthCheck(url);
    }
    return;
}
/**
 * Performs a health check on a given URL with a retry mechanism.
 * It retries fetching the URL up to MAX_RETRIES times with an exponential backoff delay.
 *
 * @param url The URL to check for health.
 * @returns A Promise that resolves if the health check is successful.
 * @throws An error if the health check fails after all retries.
 */
async function healthCheck(url) {
    const MAX_RETRIES = 10;
    const BASE_DELAY_MS = 100;
    for (let i = 0; i < MAX_RETRIES; i++) {
        try {
            const response = await fetch(url);
            if (response.ok) {
                return;
            }
        }
        catch (error) {
            console.warn(`[test-server-sdk] Health check attempt ${i + 1} failed for ${url}. Error: ${error}`);
        }
        const delay = BASE_DELAY_MS * Math.pow(2, i);
        console.log(`[test-server-sdk] Retrying health check for ${url} in ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
    }
    throw new Error(`[test-server-sdk] Health check failed for ${url} after ${MAX_RETRIES} retries.`);
}
